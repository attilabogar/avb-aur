diff -ur python-sipsimple-release-3.4.2.orig/deps/pjsip/pjsip/src/pjsip/sip_transport_tls.c python-sipsimple-release-3.4.2/deps/pjsip/pjsip/src/pjsip/sip_transport_tls.c
--- python-sipsimple-release-3.4.2.orig/deps/pjsip/pjsip/src/pjsip/sip_transport_tls.c	2019-03-26 10:12:31.000000000 +0000
+++ python-sipsimple-release-3.4.2/deps/pjsip/pjsip/src/pjsip/sip_transport_tls.c	2019-09-27 22:26:45.241915567 +0100
@@ -1629,10 +1629,13 @@
 	unsigned i;
 
 	/* Remote name may be hostname or IP address */
-	if (tls->remote_name.slen)
+	if (tls->remote_name.slen) {
 	    remote_name = &tls->remote_name;
-	else
+	    if (tls->verify_server) PJ_LOG(4,(tls->base.obj_name, "TLS verify: %.*s", remote_name->slen, remote_name->ptr));
+	}
+	else {
 	    remote_name = &tls->base.remote_name.host;
+	}
 
 	/* Start matching remote name with SubjectAltName fields of 
 	 * server certificate.
diff -ur python-sipsimple-release-3.4.2.orig/sipsimple/core/_helpers.py python-sipsimple-release-3.4.2/sipsimple/core/_helpers.py
--- python-sipsimple-release-3.4.2.orig/sipsimple/core/_helpers.py	2019-03-26 10:12:31.000000000 +0000
+++ python-sipsimple-release-3.4.2/sipsimple/core/_helpers.py	2019-09-27 22:26:45.241915567 +0100
@@ -4,6 +4,7 @@
 import random
 import socket
 import string
+import re
 
 from application.python.types import MarkerType
 from application.system import host
@@ -17,6 +18,7 @@
 
 class Route(object):
     _default_ports = dict(udp=5060, tcp=5060, tls=5061)
+    _allowed_name = re.compile('^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$', re.IGNORECASE)
 
     def __init__(self, address, port=None, transport='udp'):
         self.address = address
@@ -29,10 +31,11 @@
 
     @address.setter
     def address(self, address):
-        try:
-            socket.inet_aton(address)
-        except:
-            raise ValueError('illegal address: %s' % address)
+        if not (len(address) <= 253 and len(address) >= 1 and all(self._allowed_name.match(x) for x in address.split('.'))):
+            try:
+                socket.inet_aton(address)
+            except:
+               raise ValueError('illegal address: %s' % address)
         self._address = address
 
     @property
diff -ur python-sipsimple-release-3.4.2.orig/sipsimple/lookup.py python-sipsimple-release-3.4.2/sipsimple/lookup.py
--- python-sipsimple-release-3.4.2.orig/sipsimple/lookup.py	2019-03-26 10:12:31.000000000 +0000
+++ python-sipsimple-release-3.4.2/sipsimple/lookup.py	2019-09-27 22:32:51.119429169 +0100
@@ -270,7 +270,11 @@
                     raise DNSLookupError("Transport %s dictated by URI is not supported" % transport)
                 addresses = self._lookup_a_records(resolver, [uri.host], log_context=log_context)
                 if addresses[uri.host]:
-                    return [Route(address=addr, port=uri.port, transport=transport) for addr in addresses[uri.host]]
+                    # Don't return route w/ the IP Address if the transport is TLS
+                    if transport == 'tls':
+                        return [Route(address=uri.host, port=uri.port, transport='tls')]
+                    else:
+                        return [Route(address=addr, port=uri.port, transport=transport) for addr in addresses[uri.host]]
 
             # If the transport was already set as a parameter on the SIP URI, only do SRV lookups
             elif 'transport' in uri.parameters:
@@ -279,6 +283,10 @@
                     raise DNSLookupError("Requested lookup for URI with %s transport, but it is not supported" % transport)
                 if uri.secure and transport != 'tls':
                     raise DNSLookupError("Requested lookup for SIPS URI, but with %s transport parameter" % transport)
+                # if TLS, we defer the SRV lookup to pjsip to PASS TLS verification a'la https://tools.ietf.org/html/rfc5922#section-7.3
+                # uri.host == SIP AUS
+                if transport == 'tls':
+                    return [Route(address=uri.host, port=None, transport='tls')]
                 record_name = '%s.%s' % (transport_service_map[transport], uri.host)
                 services = self._lookup_srv_records(resolver, [record_name], log_context=log_context)
                 if services[record_name]:
@@ -288,7 +296,11 @@
                     addresses = self._lookup_a_records(resolver, [uri.host], log_context=log_context)
                     port = 5061 if transport=='tls' else 5060
                     if addresses[uri.host]:
-                        return [Route(address=addr, port=port, transport=transport) for addr in addresses[uri.host]]
+                        # Don't return route w/ the IP Address if the transport is TLS
+                        if transport == 'tls':
+                             return [Route(address=uri.host, port=port, transport='tls')]
+                        else:
+                             return [Route(address=addr, port=port, transport=transport) for addr in addresses[uri.host]]
 
             # Otherwise, it means we don't have a numeric IP address, a port isn't specified and neither is a transport. So we have to do a full NAPTR lookup
             else:
@@ -304,6 +316,12 @@
                 except dns.resolver.Timeout:
                     pointers = []
                 if pointers:
+                    for result in pointers:
+                        if 'tls' == naptr_service_transport_map[result.service]:
+                            # NAPTR TLS transport present -> all other transports ignored! (BTW, Is this the correct behaviour?)
+                            # we defer the SRV lookup to pjsip to PASS TLS verification a'la https://tools.ietf.org/html/rfc5922#section-7.3
+                            # uri.host == SIP AUS
+                            return [Route(address=uri.host, port=None, transport='tls')]
                     return [Route(address=result.address, port=result.port, transport=naptr_service_transport_map[result.service]) for result in pointers]
                 else:
                     # If that fails, try SRV lookup
@@ -325,7 +343,11 @@
                             addresses = self._lookup_a_records(resolver, [uri.host], log_context=log_context)
                             port = 5061 if transport=='tls' else 5060
                             if addresses[uri.host]:
-                                return [Route(address=addr, port=port, transport=transport) for addr in addresses[uri.host]]
+                                # Don't return route w/ the IP Address if the transport is TLS
+                                if transport == 'tls':
+                                    return [Route(address=uri.host, port=port, transport='tls')]
+                                else:
+                                    return [Route(address=addr, port=port, transport=transport) for addr in addresses[uri.host]]
         except dns.resolver.Timeout:
             raise DNSLookupError("Timeout in lookup for routes for SIP URI %s" % uri)
         else:
